"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitize = exports.getPaths = exports.getDelimitedPath = exports.serializeData = void 0;
const lodash_1 = require("lodash");
const serialize_javascript_1 = __importDefault(require("serialize-javascript"));
const on_change_1 = __importDefault(require("on-change"));
const serializeData = (data) => {
    let serialized;
    try {
        serialized = (0, serialize_javascript_1.default)(on_change_1.default.target(data));
    }
    catch (err) {
        serialized = (0, serialize_javascript_1.default)(data);
    }
    return serialized;
};
exports.serializeData = serializeData;
const getDelimitedPath = (base, key, parentIsArray) => parentIsArray ?
    base ?
        `${base}[${key}]` :
        key :
    base ?
        `${base}.${key}` :
        key;
exports.getDelimitedPath = getDelimitedPath;
/**
 * Receives data and returns a list of "paths" where data needs to be updated. For core data, this means it returns a serialised version of the data.
 * For objects and arrays it returns one entry for each
 * @param data The initial, or current data in the object
 * @param acc The current accumulator object (no shit)
 * @param basePath The path currently being checked for paths
 * @returns
 */
const getPaths = (data, acc = {}, basePath = null) => {
    if (data === '::NULL::')
        return {};
    if (!(0, lodash_1.isObject)(data)) {
        acc[basePath || '::NULL::'] = (0, exports.serializeData)(data);
        return acc;
    }
    const source = (0, lodash_1.isArray)(data) ?
        data.map((da, i) => [i, da]) :
        Object.entries(data);
    const returnPaths = source.reduce((paths, [key, value]) => {
        const path = (0, exports.getDelimitedPath)(basePath, key, (0, lodash_1.isArray)(data));
        if ((0, lodash_1.isObject)(value))
            (0, exports.getPaths)(value, paths, path);
        paths[path.toString()] = (0, exports.serializeData)(value);
        return paths;
    }, acc || {});
    return basePath
        ? returnPaths
        : { ...returnPaths, '::NULL::': (0, exports.serializeData)(data) };
};
exports.getPaths = getPaths;
const sanitize = (str) => str.replace(/[\0\\x08\\x09\\x1a\n\r"'\\]/g, (char) => {
    switch (char) {
        case '\0':
            return '\\0';
        case '\x08':
            return '\\b';
        case '\x09':
            return '\\t';
        case '\x1a':
            return '\\z';
        case '\n':
            return '\\n';
        case '\r':
            return '\\r';
        case '"':
        case "'":
        case '\\':
        case '%':
            return `\\${char}`;
        default:
            return char;
    }
});
exports.sanitize = sanitize;
//# sourceMappingURL=utils.js.map